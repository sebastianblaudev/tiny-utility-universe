
import React, { useState, useRef, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Mic, MicOff, Loader2, Check } from 'lucide-react';
import { parseVoiceCommand, ProductCommand, getAutoGeneratedCode, debugVoiceCommand } from '@/utils/voiceCommandUtils';
import { toast } from "sonner";

interface VoiceCommandButtonProps {
  onCommand: (command: ProductCommand) => void;
  isListening: boolean;
  setIsListening: (isListening: boolean) => void;
  mode?: 'product' | 'search';
  size?: 'default' | 'sm' | 'icon';
  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';
}

const VoiceCommandButton: React.FC<VoiceCommandButtonProps> = ({ 
  onCommand, 
  isListening,
  setIsListening,
  mode = 'product',
  size = 'icon',
  variant = 'outline'
}) => {
  const [transcript, setTranscript] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const [wasSuccessful, setWasSuccessful] = useState(false);
  const recognitionRef = useRef<SpeechRecognition | null>(null);
  
  useEffect(() => {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    
    if (!SpeechRecognition) {
      toast.error("Lo sentimos, el reconocimiento de voz no estÃ¡ disponible en tu navegador.");
      return;
    }
    
    recognitionRef.current = new SpeechRecognition();
    recognitionRef.current.lang = 'es-ES';
    recognitionRef.current.continuous = true;
    recognitionRef.current.interimResults = false;
    
    recognitionRef.current.onresult = (event) => {
      // Get the last result from the results array
      const current = event.results.length - 1;
      const result = event.results[current][0].transcript;
      console.log("Speech recognition result:", result);
      setTranscript(result);
      processCommand(result);
    };
    
    recognitionRef.current.onerror = (event) => {
      console.error('Error de reconocimiento de voz:', event);
      toast.error("Error en el reconocimiento de voz. Intenta de nuevo.");
      setIsListening(false);
    };
    
    recognitionRef.current.onend = () => {
      console.log("Speech recognition ended");
      if (isListening) {
        setIsListening(false);
      }
    };
    
    return () => {
      if (recognitionRef.current) {
        recognitionRef.current.onresult = null;
        recognitionRef.current.onerror = null;
        recognitionRef.current.onend = null;
      }
    };
  }, [setIsListening, isListening]);
  
  useEffect(() => {
    if (isListening && recognitionRef.current) {
      try {
        recognitionRef.current.start();
        console.log("Speech recognition started");
        const message = mode === 'search' 
          ? "Di el nombre del producto que deseas buscar" 
          : "Diga su comando para productos. Ejemplos: 'Crea un producto llamado Coca Cola con precio 20 y costo 10' o 'Edita Coca Cola, precio 25'";
        
        toast(mode === 'search' ? "Buscando por voz..." : "Escuchando...", {
          description: message,
          duration: 4000,
        });
      } catch (error) {
        console.error('Error starting speech recognition:', error);
      }
    } else if (!isListening && recognitionRef.current) {
      try {
        recognitionRef.current.stop();
        console.log("Speech recognition stopped");
      } catch (error) {
        console.error('Error stopping speech recognition:', error);
      }
    }
    
    return () => {
      if (recognitionRef.current) {
        try {
          recognitionRef.current.stop();
        } catch (error) {
          console.error('Error stopping speech recognition on cleanup:', error);
        }
      }
    };
  }, [isListening, mode]);
  
  // Modified to activate voice recognition immediately
  const handleVoiceButtonClick = () => {
    if (isListening) {
      // If already listening, stop
      setIsListening(false);
      setTranscript('');
      setWasSuccessful(false);
    } else {
      // Start listening immediately
      setIsListening(true);
    }
  };
  
  const processCommand = (commandText: string) => {
    setIsProcessing(true);
    
    try {
      if (mode === 'search') {
        // In search mode, just pass the text as is
        onCommand({ action: 'buscar', name: commandText });
        setWasSuccessful(true);
        
        // Auto-stop after successful command
        setTimeout(() => {
          setIsListening(false);
          setWasSuccessful(false);
        }, 1000);
        return;
      }
      
      // Regular product command mode
      debugVoiceCommand(commandText);
      
      const parsedCommand = parseVoiceCommand(commandText);
      
      if (!parsedCommand) {
        console.error("No se pudo reconocer el comando: ", commandText);
        setIsProcessing(false);
        return;
      }
      
      console.log("Processing command:", parsedCommand);
      
      // If it's a create command and no code is provided, generate one
      if (parsedCommand.action === 'crear' && !parsedCommand.code) {
        parsedCommand.code = getAutoGeneratedCode();
      }
      
      // Handle command
      onCommand(parsedCommand);
      setWasSuccessful(true);
      
      // Auto-stop after successful command
      setTimeout(() => {
        setIsListening(false);
        setWasSuccessful(false);
      }, 1500);
      
    } catch (error) {
      console.error("Error processing voice command:", error);
      toast.error("Error al procesar el comando de voz");
    } finally {
      setIsProcessing(false);
    }
  };
  
  return (
    <div className="relative">
      <Button
        variant={isListening ? "destructive" : variant}
        size={size}
        onClick={handleVoiceButtonClick}
        className={`relative ${size === 'icon' ? 'h-10 w-10 rounded-full' : ''}`}
        title={isListening ? "Detener reconocimiento de voz" : "Comandos de voz"}
      >
        {isListening ? (
          wasSuccessful ? (
            <Check className="h-5 w-5" />
          ) : isProcessing ? (
            <Loader2 className="h-5 w-5 animate-spin" />
          ) : (
            <MicOff className="h-5 w-5" />
          )
        ) : (
          <Mic className="h-5 w-5" />
        )}
      </Button>
      
      {transcript && isListening && (
        <div className="absolute right-0 mt-2 w-72 p-2 bg-background border rounded-md shadow-md z-10">
          <p className="text-xs font-semibold mb-1">Comando detectado:</p>
          <p className="text-sm">{transcript}</p>
        </div>
      )}
    </div>
  );
};

export default VoiceCommandButton;
